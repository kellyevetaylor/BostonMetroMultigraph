package MultiGraph;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

/**
 * This class reads a text description of a metro subway system
 * and generates a graph representation of the metro.
 *
 * Students should feel free to modify this code as needed
 *  to complete this exercise.
 *
 *<p>
 *
 * The grammar for the file is described below in BNF. A typical line
 * in the file looks like this :
 *
 * <code> 20 NorthStation   Green 19 22  Orange 15 22  </code>
 *
 * where :
 *         20 is the StationID
 *         NorthStation is the StationName
 *         Green 19 22
 *                  Green is the LineName
 *                  19 is the StationID of the outbound station
 *                  22 is the StationID of the inbound station
 *         Orange 15 22 is a LineID in which :
 *                  Orange is the LineName
 *                  15 is the StationID of the outbound station
 *                  22 is the StationID of the inbound station
 *
 *         Therefore, NorthStation has two outgoing lines.
 *
 *  note : 0 denotes the end of a line : i.e. in this case,
 *  OakGrove would be at the end of the line, as there is no other outbound
 *  station.
 *
 *<p>
 * metro-map ::= station-spec* <BR>
 * station-spec ::= station-id station-name station-line+ <BR>
 * station-id ::= (positive integer) <BR>
 * station-name ::= string <BR>
 * station-line ::= line-name station-id station-id <BR>
 *
 */

/**
 * Creates a new parser that will read the file's filename unless it doens't exist
 */
public class MetroMapParser {

    class NewLine{
        private int node1;
        private int node2;
        private String label;

        NewLine(int node1, int node2, String label){
            this.node1 = node1;
            this.node2 = node2;
            this.label = label;
        }

        NewLine(String node1, String node2, String label) {
            this(Integer.parseInt(node1), Integer.parseInt(node2), label);
        }

        int getNode1(){
            return node1;
        }

        int getNode2() {
            return node2;
        }

        String getLabel(){
            return label;
        }
    }
    private BufferedReader fileInput;

    /**
     * @effects: creates a new parser that will read from the file
     * filename unless the file does not exist. The filename should specify
     * the exact location of the file. This means it should be something like
     * /mit/$USER/6.170/ex3/bostonmetro.txt
     *
     *
     * @throws java.io.IOException if there <tt>filename</tt> cannot be read
     *
     * @returns a new MetroMapParser that will parse the file filename
     */

    public MetroMapParser(String filename) throws IOException
    {
        //a buffered reader reads line by line, returning null when file is done
        fileInput = new BufferedReader(new FileReader(filename));
    }

    /**
     * @effects: parses the file, and generates a graph from it, unless there
     * is a problem reading the file, or there is a problem with the format of the
     * file.
     *
     * @throws java.io.IOException if there is a problem reading the file
     * @throws BadFileException if there is a problem with the format of the file
     *
     * @returns the Graph generated by the file
     */

    /**
     * Parses the file and generates a graph from it
     */
    public  BostonMetroSystem generateGraphFromFile()
            throws IOException, BadFileException
    {
        BostonMetroSystem bms = new BostonMetroSystem();

        List<Station> stations = new ArrayList<>();

        List<NewLine> lines = new ArrayList<>();

        String line = fileInput.readLine();
        StringTokenizer st;
        String stationID;
        String stationName;
        String lineName;
        String outboundID, inboundID;

        while(line != null)
        {

            //STUDENT :
            //
            //in this loop, you must collect the information necessary to
            //construct your graph, and you must construct your graph as well.
            //how and where you do this will depend on the design of your graph.
            //


            //StringTokenizer is a java.util Class that can break a string into tokens
            // based on a specified delimiter.  The default delimiter is " \t\n\r\f" which
            // corresponds to the space character, the tab character, the newline character,
            // the carriage-return character and the form-feed character.
            st = new StringTokenizer(line);

            //We want to handle empty lines effectively, we just ignore them!
            if(!st.hasMoreTokens())
            {
                line = fileInput.readLine();
                continue;
            }

            //from the grammar, we know that the Station ID is the first token on the line
            stationID = st.nextToken();

            if(!st.hasMoreTokens())
            {
                throw new BadFileException("no station name");
            }

            //from the grammar, we know that the Station Name is the second token on the line.
            stationName = st.nextToken();

            bms.addStation(Integer.parseInt(stationID),stationName);
            stations.add(new Station(Integer.parseInt(stationID),stationName));

            if(!st.hasMoreTokens())
            {
                throw new BadFileException("station is on no lines");
            }


            while(st.hasMoreTokens())
            {
                lineName = st.nextToken();

                if(!st.hasMoreTokens())
                {
                    throw new BadFileException("poorly formatted line info");
                }

                outboundID = st.nextToken();

                if(!st.hasMoreTokens())
                {
                    throw new BadFileException("poorly formatted adjacent stations");
                }

                inboundID = st.nextToken();

                if(Integer.parseInt(outboundID) !=0)
                    lines.add(new NewLine(stationID,outboundID,lineName));
                if(Integer.parseInt(inboundID) !=0)
                    lines.add(new NewLine(stationID,inboundID,lineName));
            }



            line = fileInput.readLine();
        }

        for(int i=0;i<lines.size()-1;i++)
            for(int j=i+1;j<lines.size();j++)
                if(lines.get(i).getNode1() == lines.get(j).getNode2() && lines.get(i).getNode2() == lines.get(j).getNode1())
                    lines.remove(j);

        for(NewLine newLine : lines){
            Station station1 = null;
            Station station2 = null;
            for (Station station : stations) {
                if (newLine.getNode1() == station.getId())
                    station1 = station;
                if (newLine.getNode2() == station.getId())
                    station2 = station;
            }
            bms.addLine(new Line(station1, station2, newLine.getLabel()));
        }
        return bms;
    }


}





